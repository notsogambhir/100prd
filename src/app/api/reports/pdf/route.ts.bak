import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import jsPDF from 'jspdf'
import { ServerStyleSheets } from 'jspdf'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { reportType, courseId, assessmentId } = body

    if (!reportType) {
      return NextResponse.json(
        { error: 'Report type is required' },
        { status: 400 }
      )
    }

    let reportData: any

    if (reportType === 'course-attainment' && courseId) {
      reportData = await generateCourseAttainmentReport(courseId)
    } else if (reportType === 'assessment-comparison' && courseId) {
      reportData = await generateAssessmentComparisonReport(courseId)
    } else {
      return NextResponse.json(
        { error: 'Invalid report parameters' },
        { status: 400 }
      )
    }

    // Generate PDF
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    })

    // Add custom font for better Unicode support
    pdf.addFont('https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.66/fonts/Roboto/Roboto-Regular.ttf', 'Roboto', 'normal')

    // Generate PDF content
    await generatePDFContent(pdf, reportData, reportType)

    // Convert to buffer
    const pdfBuffer = Buffer.from(pdf.output('arraybuffer'))

    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${reportType}-report-${Date.now()}.pdf"`
      }
    })

  } catch (error) {
    console.error('Failed to generate PDF:', error)
    return NextResponse.json(
      { error: 'Failed to generate PDF' },
      { status: 500 }
    )
  }
}

async function generateCourseAttainmentReport(courseId: string) {
  // Get course details with COs and enrollments
  const course = await db.course.findUnique({
    where: { id: courseId },
    include: {
      program: {
        select: {
          name: true,
          code: true
        }
      },
      batch: {
        select: {
          name: true,
          startYear: true,
          endYear: true
        }
      },
      section: {
        select: {
          name: true
        }
      },
      teacher: {
        select: {
          name: true,
          email: true
        }
      },
      cos: {
        include: {
          assessmentQuestions: {
            include: {
              assessment: {
                select: {
                  type: true
                }
              },
              marks: {
                include: {
                  student: {
                    select: {
                      id: true,
                      name: true,
                      rollNumber: true
                    }
                  }
                }
              }
            }
          }
        }
      },
      enrollments: {
        include: {
          student: {
            select: {
              id: true,
              name: true,
              rollNumber: true
            }
          }
        }
      }
    }
  })

  if (!course) {
    throw new Error('Course not found')
  }

  // Calculate CO attainment for each student
  const studentCoAttainment: any[] = []
  
  for (const enrollment of course.enrollments) {
    const student = enrollment.student
    const coAttainment: any = {
      studentId: student.id,
      studentName: student.name,
      rollNumber: student.rollNumber,
      coData: {}
    }

    for (const co of course.cos) {
      let totalObtained = 0
      let totalMax = 0

      for (const question of co.assessmentQuestions) {
        const studentMark = question.marks.find(mark => mark.studentId === student.id)
        if (studentMark) {
          totalObtained += studentMark.marks
          totalMax += question.maxMarks
        }
      }

      const attainmentPercentage = totalMax > 0 ? (totalObtained / totalMax) * 100 : 0
      const meetsTarget = attainmentPercentage >= course.target
      
      coAttainment.coData[co.code] = {
        percentage: attainmentPercentage,
        meetsTarget,
        obtained: totalObtained,
        maxMarks: totalMax
      }
    }

    studentCoAttainment.push(coAttainment)
  }

  // Calculate overall CO attainment levels
  const coSummary: any[] = []
  
  for (const co of course.cos) {
    let studentsMeetingTarget = 0
    
    for (const student of studentCoAttainment) {
      if (student.coData[co.code]?.meetsTarget) {
        studentsMeetingTarget++
      }
    }
    
    const percentageMeetingTarget = course.enrollments.length > 0 
      ? (studentsMeetingTarget / course.enrollments.length) * 100 
      : 0
    
    let attainmentLevel = 0
    if (percentageMeetingTarget >= course.attainmentLevel3) attainmentLevel = 3
    else if (percentageMeetingTarget >= course.attainmentLevel2) attainmentLevel = 2
    else if (percentageMeetingTarget >= course.attainmentLevel1) attainmentLevel = 1
    
    coSummary.push({
      coCode: co.code,
      description: co.description,
      percentageMeetingTarget,
      attainmentLevel,
      studentsMeetingTarget,
      totalStudents: course.enrollments.length
    })
  }

  return {
    type: 'course-attainment',
    course: {
      code: course.code,
      name: course.name,
      program: course.program,
      batch: course.batch,
      section: course.section,
      teacher: course.teacher,
      target: course.target,
      attainmentLevels: {
        level1: course.attainmentLevel1,
        level2: course.attainmentLevel2,
        level3: course.attainmentLevel3
      }
    },
    coSummary,
    studentBreakdown: studentCoAttainment
  }
}

async function generateAssessmentComparisonReport(courseId: string) {
  const course = await db.course.findUnique({
    where: { id: courseId },
    include: {
      program: {
        select: {
          name: true,
          code: true
        }
      },
      batch: {
        select: {
          name: true
        }
      },
      section: {
        select: {
          name: true
        }
      },
      enrollments: {
        include: {
          student: {
            select: {
              id: true,
              name: true,
              rollNumber: true
            }
          }
        }
      },
      assessments: {
        include: {
          questions: {
            include: {
              marks: {
                include: {
                  student: {
                    select: {
                      id: true,
                      name: true,
                      rollNumber: true
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  })

  if (!course) {
    throw new Error('Course not found')
  }

  // Calculate assessment scores for each student
  const studentAssessmentScores: any[] = []
  
  for (const enrollment of course.enrollments) {
    const student = enrollment.student
    const assessmentScores: any = {
      studentId: student.id,
      studentName: student.name,
      rollNumber: student.rollNumber,
      assessments: {}
    }

    for (const assessment of course.assessments) {
      let totalObtained = 0
      let totalMax = 0

      for (const question of assessment.questions) {
        const studentMark = question.marks.find(mark => mark.studentId === student.id)
        if (studentMark) {
          totalObtained += studentMark.marks
          totalMax += question.maxMarks
        }
      }

      const percentage = totalMax > 0 ? (totalObtained / totalMax) * 100 : 0
      
      assessmentScores.assessments[assessment.id] = {
        name: assessment.name,
        type: assessment.type,
        percentage,
        obtained: totalObtained,
        maxMarks: totalMax
      }
    }

    studentAssessmentScores.push(assessmentScores)
  }

  return {
    type: 'assessment-comparison',
    course: {
      code: course.code,
      name: course.name,
      program: course.program,
      batch: course.batch,
      section: course.section
    },
    assessments: course.assessments.map(a => ({
      id: a.id,
      name: a.name,
      type: a.type,
      totalQuestions: a.questions.length,
      totalMarks: a.questions.reduce((sum, q) => sum + q.maxMarks, 0)
    })),
    studentScores: studentAssessmentScores
  }
}

async function generatePDFContent(pdf: any, reportData: any, reportType: string) {
  const pageWidth = pdf.internal.pageSize.getWidth()
  const pageHeight = pdf.internal.pageSize.getHeight()
  const margin = 20
  let yPosition = margin

  // Helper function to add text with word wrap
  const addText = (text: string, x: number, y: number, fontSize = 12, fontStyle = 'normal') => {
    pdf.setFontSize(fontSize)
    pdf.setFont('helvetica', fontStyle)
    
    const lines = pdf.splitTextToSize(text, pageWidth - 2 * margin, { fontSize })
    
    lines.forEach((line: string) => {
      pdf.text(line, x, y)
      y += fontSize * 0.35 // Line height
    })
    
    return y
  }

  // Helper function to add table
  const addTable = (headers: string[], data: any[][], x: number, y: number) => {
    const columnWidth = (pageWidth - 2 * margin) / headers.length
    let currentY = y

    // Add headers
    pdf.setFillColor(240, 240, 240)
    pdf.setDrawColor(0, 0, 0)
    pdf.rect(x, currentY, pageWidth - 2 * margin, 10)
    
    headers.forEach((header, index) => {
      pdf.text(header, x + index * columnWidth + 2, currentY + 7)
    })
    
    currentY += 10

    // Add data rows
    pdf.setFillColor(255, 255, 255)
    data.forEach((row, rowIndex) => {
      const rowHeight = 8
      const bgColor = rowIndex % 2 === 0 ? 255 : 248
      
      pdf.setFillColor(bgColor, bgColor, bgColor)
      pdf.rect(x, currentY, pageWidth - 2 * margin, rowHeight)
      
      headers.forEach((header, colIndex) => {
        const cellValue = row[colIndex] || ''
        pdf.text(cellValue.toString(), x + colIndex * columnWidth + 2, currentY + 6)
      })
      
      currentY += rowHeight
    })

    return currentY
  }

  // Report Header
  yPosition = addText(`${reportData.type === 'course-attainment' ? 'Course Attainment Summary' : 'Assessment Comparison Report'}`, margin, yPosition, 20, 'bold')
  yPosition += 10
  
  // Course Information
  yPosition = addText(`Course: ${reportData.course.code} - ${reportData.course.name}`, margin, yPosition)
  yPosition = addText(`Program: ${reportData.course.program?.name}`, margin, yPosition)
  yPosition = addText(`Batch: ${reportData.course.batch?.name}`, margin, yPosition)
  if (reportData.course.section) {
    yPosition = addText(`Section: ${reportData.course.section.name}`, margin, yPosition)
  }
  yPosition = addText(`Generated: ${new Date().toLocaleDateString()}`, margin, yPosition)
  yPosition += 15

  if (reportType === 'course-attainment') {
    // CO Attainment Summary
    yPosition = addText('Overall CO Attainment', margin, yPosition, 16, 'bold')
    yPosition += 10

    const coHeaders = ['CO Code', 'Description', 'Students Meeting Target', 'Percentage', 'Attainment Level']
    const coData = reportData.coSummary.map((co: any) => [
      co.coCode,
      co.description,
      `${co.studentsMeetingTarget}/${co.totalStudents}`,
      `${co.percentageMeetingTarget.toFixed(1)}%`,
      getAttainmentLevelText(co.attainmentLevel)
    ])

    yPosition = addTable(coHeaders, coData, margin, yPosition)
    yPosition += 20

    // Student Breakdown
    yPosition = addText('Student-wise Breakdown', margin, yPosition, 16, 'bold')
    yPosition += 10

    const studentHeaders = ['Roll Number', 'Student Name', ...reportData.coSummary.map((co: any) => co.coCode)]
    const studentData = reportData.studentBreakdown.map((student: any) => {
      const row: any[] = [student.rollNumber, student.name]
      reportData.coSummary.forEach((co: any) => {
        const coData = student.coData[co.coCode]
        row.push(coData ? `${coData.percentage.toFixed(1)}%` : '0%')
      })
      return row
    })

    addTable(studentHeaders, studentData, margin, yPosition)
  } else {
    // Assessment Comparison
    yPosition = addText('Assessment Performance Comparison', margin, yPosition, 16, 'bold')
    yPosition += 10

    const assessmentHeaders = ['Roll Number', 'Student Name', ...reportData.assessments.map((a: any) => `${a.name} (${a.type})`)]
    const assessmentData = reportData.studentScores.map((student: any) => {
      const row: any[] = [student.rollNumber, student.name]
      reportData.assessments.forEach((assessment: any) => {
        const assessmentData = student.assessments[assessment.id]
        row.push(assessmentData ? `${assessmentData.percentage.toFixed(1)}%` : '0%')
      })
      return row
    })

    addTable(assessmentHeaders, assessmentData, margin, yPosition)
  }
}

function getAttainmentLevelText(level: number): string {
  switch (level) {
    case 3: return 'Excellent'
    case 2: return 'Good'
    case 1: return 'Satisfactory'
    default: return 'Needs Improvement'
  }
}